{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#jetpack-compose-starter","title":"Jetpack Compose Starter \ud83d\ude80","text":"<p>A robust, production-ready template for modern Android development that takes the pain out of setting up a new project. Built on the foundation of Now In Android's architecture, this template provides a comprehensive starting point for both new and experienced Android developers.</p>"},{"location":"#apps-built-with-this-template","title":"Apps Built With This Template","text":"<p>Check out apps built with this template here.</p>"},{"location":"#why-this-template","title":"Why This Template?","text":"<ul> <li>Production-Ready Authentication: Firebase authentication with Google Sign-In and email/password</li> <li>Clean Architecture: Clear separation of concerns with a modular, scalable architecture</li> <li>Modern Tech Stack: Latest Android development tools including Jetpack Compose</li> <li>Type-Safe Navigation: Fully typed navigation using Kotlin serialization</li> <li>Robust Data Management: Repository pattern with Room and DataStore</li> <li>Firebase Integration: Auth, Firestore, Analytics, and Crashlytics</li> <li>Background Sync: Data synchronization using WorkManager</li> <li>CI/CD: Automated build, release, and deployment with GitHub Actions</li> </ul>"},{"location":"#technical-stack","title":"Technical Stack","text":""},{"location":"#core-libraries","title":"Core Libraries","text":"<ul> <li>UI: Jetpack Compose, Material3</li> <li>DI: Dagger Hilt</li> <li>Async: Kotlin Coroutines &amp; Flow</li> <li>Network: Retrofit, OkHttp</li> <li>Storage: Room DB, DataStore</li> <li>Firebase: Auth, Firestore, Analytics</li> <li>Others: WorkManager, Coil</li> </ul>"},{"location":"#build-tools","title":"Build &amp; Tools","text":"<ul> <li>Kotlin 2.0</li> <li>Gradle 8.11.1 with Version Catalogs</li> <li>Java 21</li> <li>Custom Gradle Convention Plugins</li> <li>Dokka and MkDocs for documentation</li> <li>Spotless for code formatting</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p> \ud83d\udcda Full Documentation </p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start Guide</li> <li>Firebase Setup</li> <li>Dependency Management</li> </ul>"},{"location":"#architecture-design","title":"Architecture &amp; Design","text":"<ul> <li>Architecture Overview</li> <li>Design Philosophy</li> <li>Adding New Features</li> </ul>"},{"location":"#development-tools","title":"Development Tools","text":"<ul> <li>Convention Plugins</li> <li>Code Style with Spotless</li> <li>Performance Optimization</li> <li>Useful Tips &amp; Tricks</li> </ul>"},{"location":"#deployment","title":"Deployment","text":"<ul> <li>GitHub CI/CD Setup</li> <li>Fastlane Configuration</li> </ul> <p>Qatar University Machine Learning Group <p></p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>This project follows the official Android Architecture Guidelines with some pragmatic adaptations to keep the codebase simple and maintainable.</p>"},{"location":"architecture/#architectural-principles","title":"Architectural Principles","text":"<p>The architecture is built on several key principles:</p> <ol> <li>Separation of Concerns: Each component has its own responsibility</li> <li>Single Source of Truth: Data is managed in a single place</li> <li>Unidirectional Data Flow: Data flows in one direction, events flow in the opposite</li> <li>State-Based UI: UI is a reflection of the state</li> <li>Pragmatic Simplicity: Complex patterns are only added when necessary</li> </ol>"},{"location":"architecture/#core-layers","title":"Core Layers","text":"<p>The app uses a two-layer architecture:</p> <pre><code>graph TD\n    A[UI Layer] --&gt; B[Data Layer]\n    style A fill:#4CAF50,stroke:#333,stroke-width:2px\n    style B fill:#1976D2,stroke:#333,stroke-width:2px</code></pre>"},{"location":"architecture/#ui-layer","title":"UI Layer","text":"<p>The UI layer follows MVVM pattern and consists of:</p> <ol> <li>Composable UI: Pure UI components built with Jetpack Compose</li> <li>ViewModel: Manages UI state and business logic</li> <li>UI State: Immutable data classes representing screen state</li> </ol> <p>Example UI Layer structure: <pre><code>data class HomeScreenData(\n    val items: List&lt;Item&gt; = emptyList(),\n    // other UI state properties\n)\n\n@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val repository: HomeRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(HomeScreenData()))\n    val uiState = _uiState.asStateFlow()\n}\n\n@Composable\nfun HomeScreen(\n    uiState: HomeScreenData,\n    onAction: (HomeAction) -&gt; Unit\n) {}\n</code></pre></p>"},{"location":"architecture/#data-layer","title":"Data Layer","text":"<p>The data layer handles data operations and consists of:</p> <ol> <li>Repositories: Single source of truth for data</li> <li>Data Sources: Interface with external systems (API, database, etc.)</li> <li>Models: Data representation classes</li> </ol> <p>Example Data Layer structure: <pre><code>class HomeRepositoryImpl @Inject constructor(\n    private val localDataSource: LocalDataSource,\n    private val networkDataSource: NetworkDataSource\n) : HomeRepository {\n    override fun getData(): Flow&lt;List&lt;Data&gt;&gt; = \n        networkBoundResource(\n            query = { localDataSource.getData() },\n            fetch = { networkDataSource.getData() },\n            saveFetchResult = { localDataSource.saveData(it) }\n        )\n}\n</code></pre></p> <p>!!! NOTE \"Note\"      Unlike the official guidelines, this project intentionally omits the domain layer to reduce complexity. You can add a domain layer if your app requires complex business logic or needs to share logic between multiple ViewModels.</p>"},{"location":"architecture/#state-management","title":"State Management","text":"<p>The project uses a consistent state management pattern:</p> <ol> <li> <p>UiState Wrapper: <pre><code>data class UiState&lt;T : Any&gt;(\n    val data: T,\n    val loading: Boolean = false,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre></p> </li> <li> <p>State Updates: <pre><code>// Regular state updates\n_uiState.updateState { copy(value = newValue) }\n\n// Async operations\n_uiState.updateStateWith(viewModelScope) {\n    repository.someAsyncOperation()\n}\n</code></pre></p> </li> <li> <p>State Display: <pre><code>@Composable\nfun StatefulScreen(\n    state: UiState&lt;ScreenData&gt;,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    StatefulComposable(\n        state = state,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        // UI Content\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"architecture/#dependency-injection","title":"Dependency Injection","text":"<p>The project uses Hilt for dependency injection:</p> <ul> <li>Modules: Organized by feature and core functionality</li> <li>Scoping: Primarily uses singleton scope for repositories and data sources</li> <li>Testing: Enables easy dependency replacement for testing</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>User Interaction \u2192 UI Events</li> <li>ViewModel \u2192 Business Logic</li> <li>Repository \u2192 Data Operations</li> <li>DataSource \u2192 External Systems</li> <li>Back to UI through StateFlow</li> </ol> <pre><code>graph LR\n    A[User Action] --&gt; B[ViewModel]\n    B --&gt; C[Repository]\n    C --&gt; D[Data Sources]\n    D --&gt; C\n    C --&gt; B\n    B --&gt; E[UI State]\n    E --&gt; F[UI]</code></pre>"},{"location":"architecture/#adding-a-domain-layer","title":"Adding a Domain Layer","text":"<p>If your app grows in complexity, you can add a domain layer:</p> <pre><code>class GetDataUseCase @Inject constructor(\n    private val repository: Repository\n) {\n    suspend operator fun invoke(params: Params): Result&lt;Data&gt; =\n        repository.getData(params)\n}\n</code></pre> <p>!!! TIP \"Tip\"      Consider adding a domain layer when:      - Multiple ViewModels share business logic      - Business rules become complex      - You need to transform data between layers</p>"},{"location":"architecture/#testing-strategy-upcoming","title":"Testing Strategy (Upcoming \ud83d\udea7)","text":"<p>The architecture enables different types of tests:</p> <ol> <li>UI Tests: Test Composables in isolation</li> <li>ViewModel Tests: Test state management and business logic</li> <li>Repository Tests: Test data operations</li> <li>Integration Tests: Test multiple layers together</li> </ol>"},{"location":"architecture/#best-practices","title":"Best Practices","text":"<ol> <li>Keep UI State Simple: Only include what's needed for the UI</li> <li>Single Responsibility: Each class should have one clear purpose</li> <li>Error Handling: Use Result type for operations that can fail</li> <li>Coroutines: Use structured concurrency with proper scoping</li> <li>Immutable Data: Use data classes for state and models</li> </ol>"},{"location":"dependency/","title":"Dependency Management","text":"<p>This project uses Version Catalogs and automated dependency updates to maintain a clean and up-to-date dependency management system.</p>"},{"location":"dependency/#version-catalog","title":"Version Catalog","text":"<p>Dependencies and versions are centrally managed in <code>gradle/libs.versions.toml</code>. This file serves as a single source of truth for: - Library dependencies - Plugin versions - Project configuration - SDK versions</p>"},{"location":"dependency/#structure","title":"Structure","text":"<p>The version catalog is organized into several sections:</p> <ol> <li> <p>Versions <pre><code>[versions]\n# Core versions\njava = \"21\"\nkotlin = \"2.1.10\"\n\n# SDK Configuration\nminSdk = \"24\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\n</code></pre></p> </li> <li> <p>Plugins <pre><code>[plugins]\nkotlin = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"androidGradlePlugin\" }\n</code></pre></p> </li> <li> <p>Libraries <pre><code>[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"androidxCore\" }\n</code></pre></p> </li> </ol> <p>!!! NOTE \"Note\"      Some versions in the catalog, like <code>java</code> and SDK versions, are not direct dependencies but are used by convention plugins and build configuration.</p>"},{"location":"dependency/#using-dependencies","title":"Using Dependencies","text":"<p>In your module's <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(libs.androidx.core.ktx)\n    implementation(platform(libs.androidx.compose.bom))\n}\n</code></pre> <p>For plugins: <pre><code>plugins {\n    alias(libs.plugins.kotlin)\n    alias(libs.plugins.android.library)\n}\n</code></pre></p>"},{"location":"dependency/#automated-dependency-updates","title":"Automated Dependency Updates","text":"<p>This project uses both Renovate and Dependabot to automate dependency updates.</p>"},{"location":"dependency/#renovate-setup","title":"Renovate Setup","text":"<p>The project includes a <code>renovate.json</code> configuration: <pre><code>{\n  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n  \"extends\": [\n    \"config:base\",\n    \"group:all\",\n    \":dependencyDashboard\",\n    \"schedule:daily\"\n  ]\n}\n</code></pre> To enable Renovate, install the Renovate app in your repository</p>"},{"location":"dependency/#dependabot-setup","title":"Dependabot Setup","text":"<p>The project includes a <code>.github/dependabot.yml</code> configuration: <pre><code>version: 2\nupdates:\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n\n  - package-ecosystem: \"gradle\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    groups:\n      kotlin-ksp-compose:\n        patterns:\n          - \"org.jetbrains.kotlin:*\"\n          - \"com.google.devtools.ksp\"\n          - \"androidx.compose.compiler:compiler\"\n</code></pre></p> <p>To enable Dependabot, ensure Dependabot is enabled in your repository settings</p> <p>!!! TIP \"Tip\"      You can group dependencies that you want to get updated together in dependabot config as it has been done for the <code>kotlin-ksp-group</code>.</p>"},{"location":"dependency/#best-practices","title":"Best Practices","text":"<ol> <li>Version Organization:</li> <li>Group related versions together</li> <li>Use comments to separate sections</li> <li> <p>Keep SDK configurations in a dedicated section</p> </li> <li> <p>Version References: <pre><code>[versions]\ncompose-compiler = \"1.5.3\"\n\n[libraries]\ncompose-compiler = { group = \"androidx.compose.compiler\", name = \"compiler\", version.ref = \"compose-compiler\" }\n</code></pre></p> </li> <li> <p>Version Bundles:    Use BOM (Bill of Materials) when available: <pre><code>[libraries]\ncompose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"androidxComposeBom\" }\n</code></pre></p> </li> <li> <p>Custom Properties:    Store important project configuration in the version catalog: <pre><code>[versions]\nminSdk = \"24\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\n</code></pre></p> </li> </ol> <p>!!! WARNING \"Warning\"      Don't mix different versions of the same library family. Use BOMs when available to ensure compatibility.</p>"},{"location":"dependency/#adding-new-dependencies","title":"Adding New Dependencies","text":"<ol> <li>Add the version to <code>[versions]</code> section if needed</li> <li>Add the library definition to <code>[libraries]</code> section</li> <li>Use the new dependency in your module: <pre><code>dependencies {\n    implementation(libs.your.new.dependency)\n}\n</code></pre></li> </ol>"},{"location":"fastlane/","title":"Fastlane and Play Store Setup","text":"<p>This project uses Fastlane to automate Play Store deployments. This guide will help you set up Fastlane for your deployment needs.</p>"},{"location":"fastlane/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ol> <li>Ruby installed (version 2.5 or higher)</li> <li>Bundler installed (<code>gem install bundler</code>)</li> <li>A Google Play Console account with access to your app</li> <li>A Play Store API service account (JSON key file)</li> </ol>"},{"location":"fastlane/#initial-setup","title":"Initial Setup","text":"<ol> <li>Install Fastlane:    <pre><code>gem install fastlane\n</code></pre></li> </ol> <p>!!! NOTE \"Note\"      For detailed instructions about setting up Fastlane for Android, refer to the official Android setup guide.</p> <ol> <li>Set up Play Store authentication:</li> <li>Follow the Fastlane Play Store Setup Guide to create and download your <code>play-store.json</code> service account key</li> <li>Place the <code>play-store.json</code> file in your fastlane directory</li> </ol> <p>!!! WARNING \"Warning\"      Never commit your <code>play-store.json</code> file to the repository. Make sure it's included in your <code>.gitignore</code>.</p>"},{"location":"fastlane/#configure-fastlane-files","title":"Configure Fastlane Files","text":""},{"location":"fastlane/#appfile-configuration","title":"Appfile Configuration","text":"<p>Edit the <code>fastlane/Appfile</code> to configure your app-specific information:</p> <pre><code>json_key_file(\"fastlane/play-store.json\") # Path to your Play Store service account json file\npackage_name(\"dev.your.package.name\") # Your app's package name\n</code></pre>"},{"location":"fastlane/#fastfile-configuration","title":"Fastfile Configuration","text":"<p>Edit the <code>fastlane/Fastfile</code> to define your deployment lanes:</p> <pre><code>default_platform(:android)\n\nplatform :android do\n  desc \"Deploy a new version to the Google Play\"\n  lane :deploy do\n    # Upload to Play Store\n    upload_to_play_store(\n      track: 'internal', # or 'alpha', 'beta', 'production'\n      aab: '../app/build/outputs/bundle/release/app-release.aab',\n      skip_upload_metadata: true,\n      skip_upload_images: true,\n      skip_upload_screenshots: true,\n      release_status: \"completed\",\n      version_code: ENV[\"VERSION_CODE\"].to_i\n    )\n  end\nend\n</code></pre>"},{"location":"fastlane/#metadata-management","title":"Metadata Management","text":"<p>The project includes a standard Fastlane metadata structure:</p> <pre><code>metadata/\n\u2514\u2500\u2500 android/\n    \u2514\u2500\u2500 en-US/\n        \u251c\u2500\u2500 changelogs/\n        \u251c\u2500\u2500 images/\n        \u251c\u2500\u2500 full_description.txt\n        \u251c\u2500\u2500 short_description.txt\n        \u251c\u2500\u2500 title.txt\n        \u2514\u2500\u2500 video.txt\n</code></pre> <p>To pull existing metadata from Play Store: <pre><code>fastlane supply init\n</code></pre></p> <p>!!! warning \"Important\"      For <code>supply</code> to be able to initialize, you need to have successfully uploaded an APK to your app in the Google Play Console at least once.</p> <p>!!! NOTE \"Note\"      This command downloads all your existing Play Store metadata and screenshots. It's useful when setting up a new machine or CI environment.</p>"},{"location":"fastlane/#deploying-updates","title":"Deploying Updates","text":"<ol> <li>Update your changelog:</li> <li>Edit <code>fastlane/metadata/android/en-US/changelogs/default.txt</code></li> <li> <p>Or create a version-specific changelog: <code>changelogs/&lt;version_code&gt;.txt</code></p> </li> <li> <p>Update app metadata (if needed):</p> </li> <li>Edit relevant files in <code>metadata/android/en-US/</code></li> <li> <p>Update screenshots in <code>metadata/android/en-US/images/</code></p> </li> <li> <p>Run deployment:    <pre><code>fastlane android deploy\n</code></pre></p> </li> </ol> <p>!!! TIP \"Tip\"      Our GitHub Actions workflow automatically runs the deployment when you create a new release tag. See the GitHub CI/CD guide for details.</p>"},{"location":"fastlane/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":"<ol> <li>Authentication Errors:</li> <li>Verify your <code>play-store.json</code> file is correctly placed</li> <li>Ensure the service account has appropriate permissions in Play Console</li> <li> <p>Check if the JSON key is properly formatted</p> </li> <li> <p>Upload Failures:</p> </li> <li>Verify your app's version code is incremented</li> <li>Ensure the APK/AAB is properly signed</li> <li> <p>Check if the track (internal/alpha/beta/production) exists</p> </li> <li> <p>Metadata Issues:</p> </li> <li>Validate all required metadata files exist</li> <li>Check character limits in descriptions</li> <li>Ensure screenshot dimensions meet Play Store requirements</li> </ol> <p>[!NOTE] For more detailed information about Fastlane commands and options, refer to the Fastlane supply action documentation.</p>"},{"location":"firebase/","title":"Firebase Setup","text":"<p>This project uses Firebase for authentication, Firestore database, and analytics. Follow this guide to set up Firebase for your project.</p>"},{"location":"firebase/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Google account</li> <li>Access to Firebase Console</li> <li>Android Studio</li> </ul>"},{"location":"firebase/#firebase-console-setup","title":"Firebase Console Setup","text":"<ol> <li>Create a new project in Firebase Console:</li> <li>Go to Firebase Console</li> <li>Click \"Add project\"</li> <li>Enter your project name</li> <li> <p>Follow the setup wizard</p> </li> <li> <p>Add Android app to your Firebase project:</p> </li> <li>Click on Android icon in project overview</li> <li>Register app using your package name (<code>dev.your.package.name</code>)</li> <li>Get the SHA-1 using the provided Signing Report configuration:<ul> <li>Open Android Studio</li> <li>Run the \"Signing Report\" configuration from the run configurations dropdown</li> <li>Copy the SHA-1 hash</li> </ul> </li> <li> <p>Enter the SHA-1 in Firebase console</p> </li> <li> <p>Enable Required Services:</p> </li> </ol> <p>a. Authentication:    - Go to \"Authentication\" in Firebase Console    - Click \"Get Started\"    - Enable \"Google\" sign-in method    - Enable \"Email/Password\" sign-in method    - Add your support email</p> <p>b. Firestore:    - Go to \"Firestore Database\"    - Click \"Create Database\"    - Choose your location    - Start in production mode</p>"},{"location":"firebase/#local-project-setup","title":"Local Project Setup","text":"<ol> <li>Download Configuration File:</li> <li>Download <code>google-services.json</code> from Firebase Console</li> <li>Before replacing the template file, stop Git from tracking it:    <pre><code>git update-index --skip-worktree app/google-services.json\n</code></pre></li> <li>Replace the template <code>google-services.json</code> in the <code>app</code> directory with your downloaded file</li> </ol> <p>!!! WARNING \"Warning\"      Never commit your actual <code>google-services.json</code> to version control. The template file is provided only to ensure successful builds.</p> <ol> <li>Verify Firebase Setup:</li> <li>Build and run the app</li> <li>Try signing in with Google</li> <li>Check Firebase Console to verify authentication is working</li> </ol>"},{"location":"firebase/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li>Google Sign-In Not Working:</li> <li>Verify SHA-1 is correctly added in Firebase Console</li> <li>Check if <code>google-services.json</code> is up to date</li> <li> <p>Ensure the OAuth consent screen is configured</p> </li> <li> <p>Firestore Access Issues:</p> </li> <li>Check your Firestore rules</li> <li>Verify your device has internet connection</li> <li> <p>Check if the user is properly authenticated</p> </li> <li> <p>Build Issues:</p> </li> <li>Clean and rebuild the project</li> <li>Verify <code>google-services.json</code> is in the correct location</li> <li>Check if all Firebase dependencies are resolved</li> </ol> <p>!!! TIP \"Tip\"      If you need to get the SHA-1 hash again later, you can always run the \"Signing Report\" configuration from Android Studio.</p>"},{"location":"firebase/#firebase-configuration-files","title":"Firebase Configuration Files","text":"<p>The project handles Firebase configuration files in several ways:</p> <ol> <li>Development:</li> <li>Use your local <code>google-services.json</code></li> <li> <p>Keep it private using <code>git update-index --skip-worktree</code></p> </li> <li> <p>CI/CD:</p> </li> <li>GitHub Actions workflow uses encoded secrets</li> <li>See GitHub CI/CD Setup for details</li> </ol> <p>!!! NOTE \"Note\"      The template <code>google-services.json</code> allows the project to build but won't enable Firebase services. You must replace it with your own configuration file.</p>"},{"location":"firebase/#firestore-security-rules","title":"Firestore Security Rules","text":"<p>Set up security rules in Firebase Console to protect your data:</p> <ol> <li>Go to Firestore Database</li> <li>Click on \"Rules\" tab</li> <li>Replace the default rules with the following structure:</li> </ol> <pre><code>rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Helper function to check if user is authenticated\n    function isAuthenticated() {\n      return request.auth != null;\n    }\n\n    // Helper function to check if the user is accessing their own data\n    function isUserOwner(userId) {\n      return isAuthenticated() &amp;&amp; request.auth.uid == userId;\n    }\n\n    // Helper function to validate Jetpack data structure\n    function isValidJetpack(jetpack) {\n      return jetpack.size() == 7\n        &amp;&amp; 'id' in jetpack &amp;&amp; jetpack.id is string\n        // ... other validations\n    }\n\n    // Match the specific path structure: dev.atick.jetpack/{userId}/jetpacks/{jetpackId}\n    match /dev.atick.jetpack/{userId}/jetpacks/{jetpackId} {\n      allow read: if isUserOwner(userId);\n\n      allow create: if isUserOwner(userId) \n        &amp;&amp; isValidJetpack(request.resource.data);\n\n      allow update: if isUserOwner(userId) \n        &amp;&amp; isValidJetpack(request.resource.data)\n        &amp;&amp; request.resource.data.id == resource.data.id;\n\n      allow delete: if isUserOwner(userId);\n    }\n\n    // Deny access to all other documents by default\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}\n</code></pre> <p>These rules implement several security features: - User authentication check - Data ownership validation - Document structure validation - Explicit deny-by-default for unmatched paths</p> <p>!!! warning \"Important\"      Always test your security rules thoroughly using the Firebase Console Rules Playground before deploying to production.</p>"},{"location":"firebase/#additional-setup","title":"Additional Setup","text":"<ol> <li> <p>Test Your Configuration: <pre><code>// Add this in an activity or fragment\nFirebaseAuth.getInstance().currentUser?.let {\n    Timber.d(\"Firebase Auth is working: ${it.email}\")\n}\n</code></pre></p> </li> <li> <p>Reset Git Tracking (if needed): <pre><code>git update-index --no-skip-worktree app/google-services.json\n</code></pre></p> </li> <li> <p>Multiple Environments:</p> </li> <li>Create separate Firebase projects for development and production</li> <li>Manage different <code>google-services.json</code> files for each build variant</li> </ol> <p>[!IMPORTANT] Remember to add your <code>google-services.json</code> to <code>.gitignore</code> if you're setting up the project from scratch.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you set up and run the project on your local machine.</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Clone the repository (with depth 1 to reduce clone size): <pre><code>git clone --depth 1 -b main https://github.com/atick-faisal/Jetpack-Compose-Starter.git\n</code></pre></p> </li> <li> <p>Open the project in Android Studio Hedgehog or newer</p> </li> <li> <p>Run the debug build variant: <pre><code>./gradlew assembleDebug\n</code></pre></p> </li> </ol> <p>!!! NOTE \"Note\"      The debug variant should work out of the box with the template <code>google-services.json</code> file. However, Firebase features like authentication and Firestore won't be functional until you set up your own Firebase project.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Android Studio Hedgehog or newer</li> <li>JDK 21</li> <li>An Android device or emulator running API 24 (Android 7.0) or higher</li> </ul>"},{"location":"getting-started/#setting-up-firebase-features","title":"Setting Up Firebase Features","text":"<p>To use Firebase authentication, Firestore, and analytics:</p> <ol> <li>Follow our Firebase Setup Guide to:</li> <li>Create your Firebase project</li> <li>Configure Authentication</li> <li>Set up Firestore</li> <li> <p>Get your <code>google-services.json</code></p> </li> <li> <p>Before replacing the template <code>google-services.json</code>, prevent Git from tracking changes: <pre><code>git update-index --skip-worktree app/google-services.json\n</code></pre></p> </li> <li> <p>Replace the template file at <code>app/google-services.json</code> with your own</p> </li> </ol>"},{"location":"getting-started/#release-build-setup","title":"Release Build Setup","text":"<p>To create release builds, you'll need to set up signing:</p> <ol> <li>Create a keystore file</li> <li> <p>Create <code>keystore.properties</code> in the project root: <pre><code>storePassword=your-store-password\nkeyPassword=your-key-password\nkeyAlias=your-key-alias\nstoreFile=your-keystore-file.jks\n</code></pre></p> </li> <li> <p>Place your keystore file in the <code>app/</code> directory</p> </li> </ol> <p>!!! TIP \"Tip\"      Use Android Studio's \"Generate Signed Bundle/APK\" tool to help create your keystore if you don't have one.</p> <ol> <li>Build the release variant: <pre><code>./gradlew assembleRelease\n</code></pre></li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ol> <li> <p>Understand the Architecture: Read our Architecture Overview to understand how the app is structured</p> </li> <li> <p>Setup CI/CD: Follow the GitHub CI/CD Guide to set up automation</p> </li> <li> <p>Code Style: Review the Spotless Setup for code formatting guidelines</p> </li> </ol>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<ol> <li>Build Fails:</li> <li>Ensure you have JDK 21 set in Android Studio</li> <li>Run <code>./gradlew clean</code> and try again</li> <li> <p>Check if all dependencies are resolved</p> </li> <li> <p>Firebase Features Not Working:</p> </li> <li>Verify you've replaced <code>google-services.json</code></li> <li>Check Firebase Console for proper setup</li> <li> <p>Ensure SHA-1 is added for authentication</p> </li> <li> <p>Release Build Fails:</p> </li> <li>Verify keystore.properties exists and has correct values</li> <li>Confirm keystore file is in the correct location</li> <li>Check signing configuration in build.gradle</li> </ol> <p>!!! warning \"Important\"      Never commit sensitive files like <code>keystore.properties</code>, your keystore file, or your real <code>google-services.json</code> to version control.</p>"},{"location":"getting-started/#ide-setup","title":"IDE Setup","text":"<p>For the best development experience:</p> <ol> <li>Enable Compose Preview:</li> <li>Ensure \"Live Edit of Literals\" is enabled</li> <li> <p>Configure appropriate preview devices</p> </li> <li> <p>Run Configurations:</p> </li> <li>Use provided run configurations for common tasks</li> <li> <p>Signing Report configuration helps get SHA-1 for Firebase</p> </li> <li> <p>Code Style:</p> </li> <li>Import the project's <code>.editorconfig</code></li> <li>Enable \"Format on Save\" for Kotlin files</li> <li>Use the Spotless plugin for consistent formatting</li> </ol>"},{"location":"github/","title":"GitHub CI/CD Setup","text":"<p>This project uses GitHub Actions for continuous integration and deployment. We have three main workflows:</p>"},{"location":"github/#build-workflow","title":"Build Workflow","text":"<p>The build workflow runs on every pull request and when libraries are updated. It performs the following tasks:</p> <ul> <li>Validates Gradle wrapper</li> <li>Sets up JDK 21</li> <li>Runs code style checks using Spotless</li> <li>Builds the project</li> </ul> <p>!!! NOTE \"Note\"      The build workflow runs automatically and requires no additional setup.</p>"},{"location":"github/#documentation-workflow","title":"Documentation Workflow","text":"<p>The documentation workflow runs whenever changes are pushed to the main branch. It:</p> <ul> <li>Sets up Python and required dependencies</li> <li>Generates API documentation using Dokka</li> <li>Deploys documentation to GitHub Pages</li> </ul> <p>!!! NOTE \"Note\"      The documentation workflow runs automatically and requires no additional setup. Make sure your repository has GitHub Pages enabled in the settings.</p>"},{"location":"github/#release-workflow","title":"Release Workflow","text":"<p>The release workflow is triggered when you push a tag with the format <code>v*.*.*</code> (e.g., v1.0.0). It:</p> <ul> <li>Builds a signed release APK</li> <li>Creates a GitHub release with the APK</li> <li>Deploys to Google Play Store using Fastlane</li> </ul>"},{"location":"github/#prerequisites","title":"Prerequisites","text":"<p>Before you can use the release workflow, you need to set up the following GitHub secrets:</p> <ol> <li> <p><code>GOOGLE_SERVICES</code>: Base64 encoded content of your <code>google-services.json</code> file    <pre><code>base64 -i google-services.json | tr -d '\\n'\n</code></pre></p> </li> <li> <p><code>KEYSTORE</code>: Base64 encoded content of your keystore file    <pre><code>base64 -i your-keystore.jks | tr -d '\\n'\n</code></pre></p> </li> <li> <p><code>KEYSTORE_PROPERTIES</code>: Base64 encoded content of your keystore.properties file containing:    <pre><code>storeFile=key.jks\nstorePassword=your-store-password\nkeyAlias=your-key-alias\nkeyPassword=your-key-password\n</code></pre></p> </li> </ol> <p>!!! WARNING \"Warning\"      Never commit your keystore file, keystore properties, or google-services.json directly to the repository.</p>"},{"location":"github/#creating-a-release","title":"Creating a Release","text":"<p>To create a new release:</p> <ol> <li>Update the <code>CHANGELOG.md</code> file with your release notes</li> <li>Create and push a new tag:    <pre><code>git tag -a v1.0.0 -m \"Release v1.0.0\"\ngit push origin v1.0.0\n</code></pre></li> </ol> <p>The workflow will automatically: - Generate a signed APK - Create a GitHub release with the changelog - Upload the APK to the release - Deploy to Play Store via Fastlane</p> <p>!!! TIP \"Tip\"      Make sure your Fastlane setup is complete before using the release workflow. See the Fastlane Setup guide for details.</p>"},{"location":"github/#debugging-failed-releases","title":"Debugging Failed Releases","text":"<p>If the release workflow fails, check:</p> <ol> <li>GitHub Secrets are properly set</li> <li>Tag format follows <code>v*.*.*</code> pattern</li> <li><code>CHANGELOG.md</code> exists and is properly formatted</li> <li>Fastlane configuration is correct</li> <li>Keystore and signing configuration match Play Store requirements</li> </ol> <p>[!NOTE] The workflow timeout is set to 45 minutes. For large projects, you might need to adjust this in the workflow file.</p>"},{"location":"guide/","title":"Adding a New Feature","text":"<p>This guide walks through the process of adding a new feature to the app, following our established patterns and best practices.</p>"},{"location":"guide/#overview-of-steps","title":"Overview of Steps","text":"<ol> <li>Define data models</li> <li>Create/update data sources</li> <li>Create repository layer</li> <li>Create UI layer</li> <li>Set up navigation</li> <li>Configure dependency injection</li> </ol>"},{"location":"guide/#step-1-data-models","title":"Step 1: Data Models","text":""},{"location":"guide/#11-data-source-models","title":"1.1 Data Source Models","text":"<p>Create models in appropriate core module (for example, <code>core:network</code> or <code>core:room</code>). Feel free to create your own if its not present in the template:</p> <pre><code>// core/network/src/main/kotlin/dev/atick/core/network/models/NetworkFeature.kt\n@Serializable\ndata class NetworkFeature(\n    val id: String,\n    val name: String,\n    val createdAt: Long = System.currentTimeMillis()\n)\n\n// core/room/src/main/kotlin/dev/atick/core/room/models/FeatureEntity.kt\n@Entity(tableName = \"features\")\ndata class FeatureEntity(\n    @PrimaryKey val id: String,\n    val name: String,\n    val lastSynced: Long = 0,\n    val needsSync: Boolean = true\n)\n</code></pre>"},{"location":"guide/#step-2-data-sources","title":"Step 2: Data Sources","text":""},{"location":"guide/#21-network-data-source","title":"2.1 Network Data Source","text":"<pre><code>// core/network/src/main/kotlin/dev/atick/core/network/data/\ninterface NetworkDataSource {\n    suspend fun getFeatures(): List&lt;NetworkFeature&gt;\n    suspend fun createFeature(feature: NetworkFeature)\n}\n\nclass NetworkDataSourceImpl @Inject constructor(\n    private val api: FeatureApi,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : NetworkDataSource {\n    override suspend fun getFeatures(): List&lt;NetworkFeature&gt; =\n        withContext(ioDispatcher) {\n            api.getFeatures()\n        }\n\n    override suspend fun createFeature(feature: NetworkFeature) =\n        withContext(ioDispatcher) {\n            api.createFeature(feature)\n        }\n}\n</code></pre>"},{"location":"guide/#22-local-data-source","title":"2.2 Local Data Source","text":"<pre><code>// core/room/src/main/kotlin/dev/atick/core/room/data/\ninterface LocalDataSource {\n    fun observeFeatures(): Flow&lt;List&lt;FeatureEntity&gt;&gt;\n    suspend fun saveFeatures(features: List&lt;FeatureEntity&gt;)\n}\n\nclass LocalDataSourceImpl @Inject constructor(\n    private val featureDao: FeatureDao,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : LocalDataSource {\n    override fun observeFeatures(): Flow&lt;List&lt;FeatureEntity&gt;&gt; =\n        featureDao.observeFeatures()\n            .flowOn(ioDispatcher)\n\n    override suspend fun saveFeatures(features: List&lt;FeatureEntity&gt;) =\n        withContext(ioDispatcher) {\n            featureDao.insertFeatures(features)\n        }\n}\n</code></pre> <p>!!! NOTE \"Note\"      Always use <code>withContext(ioDispatcher)</code> in data sources to ensure operations run on the IO thread.</p>"},{"location":"guide/#step-3-repository-layer","title":"Step 3: Repository Layer","text":""},{"location":"guide/#31-feature-models","title":"3.1 Feature Models","text":"<pre><code>// data/src/main/kotlin/dev/atick/data/models/Feature.kt\ndata class Feature(\n    val id: String,\n    val name: String,\n    val lastSynced: Long = 0\n)\n\n// Conversion Functions\nfun NetworkFeature.toFeature() = Feature(\n    id = id,\n    name = name\n)\n\nfun FeatureEntity.toFeature() = Feature(\n    id = id,\n    name = name,\n    lastSynced = lastSynced\n)\n\nfun Feature.toEntity() = FeatureEntity(\n    id = id,\n    name = name,\n    lastSynced = lastSynced\n)\n</code></pre>"},{"location":"guide/#32-repository-implementation","title":"3.2 Repository Implementation","text":"<pre><code>// data/src/main/kotlin/dev/atick/data/repository/\ninterface FeatureRepository {\n    fun observeFeatures(): Flow&lt;List&lt;Feature&gt;&gt;\n    suspend fun createFeature(feature: Feature): Result&lt;Unit&gt;\n    suspend fun syncFeatures(): Result&lt;Unit&gt;\n}\n\nclass FeatureRepositoryImpl @Inject constructor(\n    private val localDataSource: LocalDataSource,\n    private val networkDataSource: NetworkDataSource\n) : FeatureRepository {\n    override fun observeFeatures(): Flow&lt;List&lt;Feature&gt;&gt; =\n        localDataSource.observeFeatures()\n            .map { entities -&gt; entities.map { it.toFeature() } }\n\n    override suspend fun createFeature(feature: Feature): Result&lt;Unit&gt; =\n        suspendRunCatching {\n            networkDataSource.createFeature(feature.toNetworkFeature())\n            localDataSource.saveFeature(feature.toEntity())\n        }\n\n    override suspend fun syncFeatures(): Result&lt;Unit&gt; =\n        suspendRunCatching {\n            val networkFeatures = networkDataSource.getFeatures()\n            val entities = networkFeatures.map { it.toFeature().toEntity() }\n            localDataSource.saveFeatures(entities)\n        }\n}\n</code></pre> <p>!!! TIP \"Tip\"      Use <code>suspendRunCatching</code> in repositories to handle errors consistently.</p>"},{"location":"guide/#step-4-ui-layer","title":"Step 4: UI Layer","text":""},{"location":"guide/#41-ui-models","title":"4.1 UI Models","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/models/\ndata class FeatureScreenData(\n    val features: List&lt;Feature&gt; = emptyList(),\n    val newFeatureName: String = \"\"\n)\n</code></pre>"},{"location":"guide/#42-viewmodel","title":"4.2 ViewModel","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/ui/\n@HiltViewModel\nclass FeatureViewModel @Inject constructor(\n    private val featureRepository: FeatureRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(FeatureScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        observeFeatures()\n    }\n\n    private fun observeFeatures() {\n        featureRepository.observeFeatures()\n            .onEach { features -&gt;\n                _uiState.updateState {\n                    copy(features = features)\n                }\n            }\n            .launchIn(viewModelScope)\n    }\n\n    fun updateFeatureName(name: String) {\n        _uiState.updateState {\n            copy(newFeatureName = name)\n        }\n    }\n\n    fun createFeature() {\n        _uiState.updateStateWith(viewModelScope) {\n            val feature = Feature(\n                id = UUID.randomUUID().toString(),\n                name = newFeatureName\n            )\n            featureRepository.createFeature(feature)\n        }\n    }\n}\n</code></pre>"},{"location":"guide/#43-ui-components","title":"4.3 UI Components","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/ui/\n@Composable\nfun FeatureRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: FeatureViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        FeatureScreen(\n            screenData = screenData,\n            onNameChange = viewModel::updateFeatureName,\n            onCreateFeature = viewModel::createFeature\n        )\n    }\n}\n\n@Composable\nprivate fun FeatureScreen(\n    screenData: FeatureScreenData,\n    onNameChange: (String) -&gt; Unit,\n    onCreateFeature: () -&gt; Unit\n) {\n    Column(modifier = Modifier.fillMaxSize()) {\n        // UI Implementation\n    }\n}\n</code></pre>"},{"location":"guide/#step-5-navigation","title":"Step 5: Navigation","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/navigation/\n@Serializable\ndata object FeatureNavGraph\n\n@Serializable\ndata object Feature\n\nfun NavController.navigateToFeature(\n    navOptions: NavOptions? = null\n) {\n    navigate(Feature, navOptions)\n}\n\nfun NavGraphBuilder.featureScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    composable&lt;Feature&gt; {\n        FeatureRoute(onShowSnackbar = onShowSnackbar)\n    }\n}\n\nfun NavGraphBuilder.featureNavGraph(\n    nestedGraphs: NavGraphBuilder.() -&gt; Unit\n) {\n    navigation&lt;FeatureNavGraph&gt;(\n        startDestination = Feature\n    ) {\n        nestedGraphs()\n    }\n}\n</code></pre>"},{"location":"guide/#step-6-dependency-injection","title":"Step 6: Dependency Injection","text":""},{"location":"guide/#61-data-source-module","title":"6.1 Data Source Module","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class DataSourceModule {\n    @Binds\n    @Singleton\n    abstract fun bindNetworkDataSource(\n        impl: NetworkDataSourceImpl\n    ): NetworkDataSource\n}\n</code></pre>"},{"location":"guide/#62-repository-module","title":"6.2 Repository Module","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    @Singleton\n    abstract fun bindFeatureRepository(\n        impl: FeatureRepositoryImpl\n    ): FeatureRepository\n}\n</code></pre>"},{"location":"guide/#best-practices-reminder","title":"Best Practices Reminder","text":"<ol> <li>Data Sources:</li> <li>Use <code>withContext(ioDispatcher)</code> for IO operations</li> <li>Handle raw data models</li> <li> <p>One responsibility per data source</p> </li> <li> <p>Repositories:</p> </li> <li>Use <code>suspendRunCatching</code> for error handling</li> <li>Convert between data models</li> <li> <p>Coordinate between data sources</p> </li> <li> <p>ViewModels:</p> </li> <li>Use <code>updateState</code> and <code>updateStateWith</code> utilities</li> <li>Handle UI logic and state management</li> <li> <p>Convert to UI models</p> </li> <li> <p>UI Components:</p> </li> <li>Use <code>StatefulComposable</code> for consistent loading/error handling</li> <li>Keep composables pure and state-driven</li> <li>Separate route from screen implementation</li> </ol> <p>!!! warning \"Important\"      Always follow the unidirectional data flow pattern: UI Events \u2192 ViewModel \u2192 Repository \u2192 Data Sources \u2192 Back to UI through StateFlow.</p>"},{"location":"guide/#testing-upcoming","title":"Testing (Upcoming \ud83d\udea7)","text":"<p>Remember to add tests for your new feature:</p> <ol> <li>Data Source Tests: Test IO operations</li> <li>Repository Tests: Test business logic</li> <li>ViewModel Tests: Test state management</li> <li>UI Tests: Test composables</li> <li>Integration Tests: Test full feature flow</li> </ol>"},{"location":"performance/","title":"Performance Optimizations","text":"<p>This guide covers various performance optimization features available in the project.</p>"},{"location":"performance/#compose-compiler-metrics","title":"Compose Compiler Metrics","text":"<p>The project includes built-in support for Compose compiler metrics to help optimize your composables.</p> <p>Check the <code>gradle.properties</code> file to ensure the following: <pre><code>enableComposeCompilerMetrics=true\nenableComposeCompilerReports=true\n</code></pre></p> <p>This configuration will generate detailed reports in: - <code>build/&lt;module&gt;/compose-metrics</code>: Composition metrics - <code>build/&lt;module&gt;/compose-reports</code>: Compiler reports</p>"},{"location":"performance/#using-the-reports","title":"Using the Reports","text":"<ol> <li>Skippability Report: Shows which composables can't skip recomposition</li> <li>Events Report: Details composition events</li> <li>Metrics Report: Performance metrics for each composable</li> </ol>"},{"location":"performance/#optimizing-composables","title":"Optimizing Composables","text":"<p>Use the reports to identify and fix recomposition issues:</p> <pre><code>// Bad: Class not marked as stable\ndata class UiState(\n    val mutableList: MutableList&lt;String&gt; // Unstable type\n)\n\n// Good: Stable class with immutable properties\n@Immutable\ndata class UiState(\n    val list: List&lt;String&gt; // Immutable type\n)\n</code></pre> <p>Common optimizations: <pre><code>// Mark data classes as stable\n@Stable\ndata class YourData(...)\n\n// Use immutable collections\nval items: ImmutableList&lt;Item&gt;\n\n// Remember expensive computations\nval filteredList = remember(items) {\n    items.filter { ... }\n}\n</code></pre></p> <p>!!! TIP \"Tip\"      Use <code>@Immutable</code> for classes that never change and <code>@Stable</code> for classes whose properties may change but maintain identity.</p>"},{"location":"performance/#r8-and-proguard-optimization","title":"R8 and ProGuard Optimization","text":""},{"location":"performance/#project-structure-for-obfuscation","title":"Project Structure for Obfuscation","text":"<p>The project follows a consistent pattern for data models to simplify ProGuard/R8 rules: <pre><code>\u251c\u2500\u2500 feature/\n\u2502   \u2514\u2500\u2500 your-feature/\n\u2502       \u2514\u2500\u2500 models/  // Models kept unobfuscated\n\u2514\u2500\u2500 core/\n    \u2514\u2500\u2500 network/\n        \u2514\u2500\u2500 models/  // Data models kept unobfuscated\n</code></pre></p>"},{"location":"performance/#proguard-and-consumer-rules","title":"ProGuard and Consumer Rules","text":"<p>If your app works in <code>debug</code> build but not in <code>release</code> build that typically indicates obfuscation issues. In that case you need to add or edit the proguard rules. These can be found in /proguard-rules.pro for /consumer-rules.pro files. For example: <pre><code># Keep all models\n-keep class **.models.** { *; }\n\n# Keep Kotlinx Serialization\n-keepattributes *Annotation*, InnerClasses\n-dontnote kotlinx.serialization.AnnotationsKt\n</code></pre> <p>!!! NOTE \"Note\"      The project's model organization makes it easy to keep data models unobfuscated while allowing safe obfuscation of implementation classes.</p>"},{"location":"performance/#gradle-build-optimization","title":"Gradle Build Optimization","text":""},{"location":"performance/#build-scan","title":"Build Scan","text":"<p>The project includes Gradle Enterprise build scan support:</p> <pre><code>// settings.gradle.kts\nplugins {\n    id(\"com.gradle.develocity\") version (\"3.19.1\")\n}\n\ndevelocity {\n    buildScan {\n        publishing.onlyIf { !System.getenv(\"CI\").isNullOrEmpty() }\n        termsOfUseUrl.set(\"https://gradle.com/help/legal-terms-of-use\")\n        termsOfUseAgree.set(\"yes\")\n    }\n}\n</code></pre> <p>Use build scans to: - Identify slow tasks - Find configuration issues - Optimize dependency resolution</p>"},{"location":"performance/#multi-module-build-optimization","title":"Multi-Module Build Optimization","text":"<p>Take advantage of the project's modular structure:</p> <ol> <li>Make Module: Instead of rebuilding the entire project, use Make Module:</li> <li>Android Studio: Right-click module \u2192 Make Module</li> <li> <p>Command Line: <code>./gradlew :module:name:assembleDebug</code></p> </li> <li> <p>Parallel Execution: Enabled in <code>gradle.properties</code>:    <pre><code>org.gradle.parallel=true\n</code></pre></p> </li> <li> <p>Configuration Caching: Already enabled for supported tasks</p> </li> </ol> <p>!!! TIP \"Tip\"      When working on a feature, use Make Module on just that feature's module to significantly reduce build time.</p>"},{"location":"performance/#baseline-profiles","title":"Baseline Profiles","text":"<p>!!! NOTE \"Note\"      Baseline profile support is coming soon to improve app startup performance.</p>"},{"location":"performance/#planned-implementation","title":"Planned Implementation","text":"<pre><code>// build.gradle.kts\nandroidApplication {\n    baselineProfile {\n        automaticGenerationDuringBuild = true\n    }\n}\n</code></pre> <p>This will include: - Startup trace collection - Critical user path optimization - Ahead-of-time compilation for key paths</p>"},{"location":"performance/#firebase-performance-monitoring","title":"Firebase Performance Monitoring","text":"<p>This template includes Firebase Performance Monitoring setup through the Firebase convention plugin:</p> <pre><code>// FirebaseConventionPlugin.kt\nclass FirebaseConventionPlugin : Plugin&lt;Project&gt; {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"com.google.firebase.firebase-perf\")\n            }\n\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"firebase.perf\").get())\n            }\n        }\n    }\n}\n</code></pre> <p>This gives you automatic monitoring of: - Network requests - App startup time - Screen render time - Frozen frames</p> <p>You can also add custom traces: <pre><code>FirebasePerformance.getInstance().newTrace(\"custom_operation\").apply {\n    start()\n    // Your code here\n    stop()\n}\n</code></pre></p> <p>!!! TIP \"Tip\"      Use the Firebase Console to view performance metrics and identify bottlenecks in your app.</p>"},{"location":"performance/#additional-performance-tips","title":"Additional Performance Tips","text":"<ol> <li> <p>Image Loading: <pre><code>// Use Coil's memory cache\nImageLoader(context) {\n    memoryCachePolicy(CachePolicy.ENABLED)\n    diskCachePolicy(CachePolicy.ENABLED)\n}\n</code></pre></p> </li> <li> <p>List Performance: <pre><code>// Use LazyColumn with keys\nLazyColumn {\n    items(\n        items = items,\n        key = { it.id } // Stable key for better recomposition\n    ) { item -&gt;\n        // Item content\n    }\n}\n</code></pre></p> </li> <li> <p>State Hoisting: <pre><code>// Hoist state for better recomposition control\n@Composable\nfun StatefulComponent(\n    state: State, // Hoisted state\n    onStateChange: (State) -&gt; Unit\n)\n</code></pre></p> </li> <li> <p>Navigation Performance: <pre><code>// Use NavOptions to control back stack. In JetpackAppState.kt:\nnavController.navigate(route) {\n    launchSingleTop = true\n    restoreState = true\n}\n</code></pre></p> </li> </ol> <p>[!IMPORTANT] Always profile your app's performance using Android Studio's CPU Profiler and Layout Inspector before and after optimizations to ensure they're effective.</p>"},{"location":"philosophy/","title":"Design Philosophy","text":"<p>This project prioritizes pragmatic simplicity over theoretical purity, making conscious trade-offs that favor maintainability and readability over absolute correctness or flexibility.</p>"},{"location":"philosophy/#core-principles","title":"Core Principles","text":""},{"location":"philosophy/#1-pragmatic-simplicity","title":"1. Pragmatic Simplicity","text":"<p>We favor straightforward, understandable solutions over complex but theoretically \"pure\" ones. This means:</p> <ul> <li>Using direct state management approaches</li> <li>Minimizing layers when possible</li> <li>Keeping code readable and debuggable</li> </ul>"},{"location":"philosophy/#2-centralized-state-management","title":"2. Centralized State Management","text":""},{"location":"philosophy/#uistate-wrapper","title":"UiState Wrapper","text":"<p>All UI state is wrapped in a consistent structure: <pre><code>data class UiState&lt;T : Any&gt;(\n    val data: T,\n    val loading: Boolean = false,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre></p>"},{"location":"philosophy/#statefulcomposable-pattern","title":"StatefulComposable Pattern","text":"<p>Instead of implementing error and loading states individually for each screen, we handle these centrally:</p> <pre><code>@Composable\nfun &lt;T : Any&gt; StatefulComposable(\n    state: UiState&lt;T&gt;,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    content: @Composable (T) -&gt; Unit\n) {\n    // Centralized loading and error handling\n    content(state.data)\n}\n</code></pre> <p>!!! NOTE \"Note\"      This approach trades some flexibility for consistency and reduced boilerplate.</p>"},{"location":"philosophy/#3-direct-viewmodels","title":"3. Direct ViewModels","text":"<p>We opt for a direct approach to state management in ViewModels:</p> <pre><code>class AuthViewModel @Inject constructor(\n    private val authRepository: AuthRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(AuthScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun updateEmail(email: String) {\n        _uiState.updateState {\n            copy(\n                email = TextFiledData(\n                    value = email,\n                    errorMessage = email.validateEmail()\n                )\n            )\n        }\n    }\n}\n</code></pre> <p>Trade-offs Made: - \u2705 Readability: State changes are explicit and easy to trace - \u2705 Debuggability: Direct state mutations are easier to debug - \u2705 Simplicity: Easier to manage multiple UI events - \u274c Purity: Less adherence to functional programming principles</p>"},{"location":"philosophy/#4-error-handling","title":"4. Error Handling","text":"<p>We use a consistent error handling approach throughout the app:</p> <ol> <li> <p>Repository Layer: Uses <code>Result</code> type <pre><code>suspend fun getData(): Result&lt;Data&gt; = suspendRunCatching {\n    dataSource.getData()\n}\n</code></pre></p> </li> <li> <p>ViewModel Layer: Converts to <code>OneTimeEvent</code> <pre><code>viewModelScope.launch {\n    repository.getData()\n        .onSuccess { data -&gt; \n            _uiState.updateState { copy(data = data) }\n        }\n        .onFailure { error -&gt;\n            _uiState.updateState { \n                copy(error = OneTimeEvent(error))\n            }\n        }\n}\n</code></pre></p> </li> <li> <p>UI Layer: Handled by <code>StatefulComposable</code></p> </li> </ol> <p>!!! TIP \"Tip\"      This standardized approach makes error handling predictable across the entire application.</p>"},{"location":"philosophy/#5-state-updates","title":"5. State Updates","text":"<p>We provide extension functions for common state update patterns:</p> <pre><code>// Regular state updates\n_uiState.updateState { \n    copy(value = newValue) \n}\n\n// Async operations with loading state\n_uiState.updateStateWith(viewModelScope) {\n    repository.someAsyncOperation()\n}\n</code></pre>"},{"location":"philosophy/#6-feature-organization","title":"6. Feature Organization","text":"<p>Each feature is self-contained and follows a consistent structure: <pre><code>feature/\n\u2514\u2500\u2500 auth/\n    \u251c\u2500\u2500 navigation/    # Navigation-related code\n    \u251c\u2500\u2500 ui/           # UI components and ViewModels\n    \u2514\u2500\u2500 models/       # Feature-specific models\n</code></pre></p>"},{"location":"philosophy/#conscious-trade-offs","title":"Conscious Trade-offs","text":"<p>Our design philosophy makes several conscious trade-offs:</p> <ol> <li>Simplicity vs. Flexibility</li> <li>We choose simpler solutions even if they're less flexible</li> <li> <p>Custom solutions are added only when really needed</p> </li> <li> <p>Convention vs. Configuration</p> </li> <li>We favor strong conventions over configuration options</li> <li> <p>This reduces decision fatigue but may limit customization</p> </li> <li> <p>Pragmatism vs. Purity</p> </li> <li>We prioritize practical solutions over theoretical purity</li> <li> <p>This may mean occasionally breaking \"clean\" architecture rules</p> </li> <li> <p>Consistency vs. Optimization</p> </li> <li>We prefer consistent patterns across the codebase</li> <li>This might mean using the same solution even when a specialized one might be marginally better</li> </ol> <p>!!! warning \"Important\"      These patterns are guidelines, not rules. The goal is to make the codebase more maintainable and easier to understand, not to restrict flexibility where it's truly needed.</p>"},{"location":"philosophy/#benefits-of-this-approach","title":"Benefits of This Approach","text":"<ol> <li>Reduced Cognitive Load</li> <li>Developers can predict where to find things</li> <li> <p>Common patterns reduce decision fatigue</p> </li> <li> <p>Easier Onboarding</p> </li> <li>New team members can quickly understand the codebase</li> <li> <p>Consistent patterns make learning curve smoother</p> </li> <li> <p>Better Maintainability</p> </li> <li>Common patterns make code more predictable</li> <li> <p>Centralized handling reduces bugs</p> </li> <li> <p>Improved Debugging</p> </li> <li>State changes are explicit and traceable</li> <li>Error handling is consistent and predictable</li> </ol>"},{"location":"philosophy/#when-to-break-these-rules","title":"When to Break These Rules","text":"<p>While these patterns serve well for most cases, consider alternatives when:</p> <ol> <li>A feature has unique error/loading UI requirements</li> <li>Performance optimizations are crucial</li> <li>Complex business logic demands more separation</li> <li>Third-party integration requires different patterns</li> </ol> <p>[!TIP] When deviating from these patterns, document your reasoning to help other developers understand the context of your decisions.</p>"},{"location":"plugins/","title":"Convention Plugins","text":"<p>This project uses Gradle Convention Plugins to centralize common build logic and simplify module-level build files. These plugins are located in the <code>build-logic</code> directory.</p>"},{"location":"plugins/#available-plugins","title":"Available Plugins","text":""},{"location":"plugins/#1-application-plugin-devatickapplication","title":"1. Application Plugin (<code>dev.atick.application</code>)","text":"<p>Used for the main application module: - Configures Android application defaults - Sets up Compose - Enables BuildConfig - Configures Kotlin and Java versions - Sets up Compose compiler metrics and reports</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.application)\n}\n</code></pre>"},{"location":"plugins/#2-library-plugin-devaticklibrary","title":"2. Library Plugin (<code>dev.atick.library</code>)","text":"<p>Base plugin for Android library modules: - Configures Android library defaults - Sets up Kotlin - Configures Java versions - Enables KotlinX Serialization</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.library)\n}\n</code></pre>"},{"location":"plugins/#3-ui-library-plugin-devatickuilibrary","title":"3. UI Library Plugin (<code>dev.atick.ui.library</code>)","text":"<p>Extended library plugin for UI modules: - Includes all Library Plugin features - Enables Jetpack Compose - Adds Material3 experimental opt-ins</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library)\n}\n</code></pre>"},{"location":"plugins/#4-dagger-hilt-plugin-devatickdaggerhilt","title":"4. Dagger Hilt Plugin (<code>dev.atick.dagger.hilt</code>)","text":"<p>Sets up Dagger Hilt in a module: - Applies Hilt Android plugin - Adds KSP for annotation processing - Configures Hilt dependencies</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.dagger.hilt)\n}\n</code></pre>"},{"location":"plugins/#5-firebase-plugin-devatickfirebase","title":"5. Firebase Plugin (<code>dev.atick.firebase</code>)","text":"<p>Configures Firebase services: - Sets up Firebase BoM - Configures Analytics, Crashlytics, and Performance - Applies necessary Google Services plugins</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.firebase)\n}\n</code></pre>"},{"location":"plugins/#using-the-plugins","title":"Using the Plugins","text":"<p>To use these plugins in your module's <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library)\n    alias(libs.plugins.jetpack.dagger.hilt)\n    // Add other plugins as needed\n}\n</code></pre> <p>!!! NOTE \"Note\"      The plugins are already registered in the version catalog (<code>libs.versions.toml</code>), making them easily accessible across all modules.</p>"},{"location":"plugins/#creating-custom-plugins","title":"Creating Custom Plugins","text":"<p>To create your own convention plugin:</p> <ol> <li>Add your plugin class in <code>build-logic/convention/src/main/kotlin</code>:</li> </ol> <pre><code>class CustomConventionPlugin : Plugin&lt;Project&gt; {\n    override fun apply(target: Project) {\n        with(target) {\n            // Your plugin configuration here\n        }\n    }\n}\n</code></pre> <ol> <li>Register it in <code>build-logic/convention/build.gradle.kts</code>:</li> </ol> <pre><code>gradlePlugin {\n    plugins {\n        register(\"customPlugin\") {\n            id = \"dev.your.plugin.id\"\n            implementationClass = \"CustomConventionPlugin\"\n        }\n    }\n}\n</code></pre> <ol> <li>Add it to <code>libs.versions.toml</code>:</li> </ol> <pre><code>[plugins]\ncustom-plugin = { id = \"dev.your.plugin.id\" }\n</code></pre>"},{"location":"plugins/#plugin-development-tips","title":"Plugin Development Tips","text":"<ol> <li> <p>Accessing Version Catalog: <pre><code>val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(\"libs\")\nval version = libs.findVersion(\"your.version\").get()\n</code></pre></p> </li> <li> <p>Configuring Android Extensions: <pre><code>extensions.configure&lt;LibraryExtension&gt; {\n    // Your configuration\n}\n</code></pre></p> </li> <li> <p>Adding Dependencies: <pre><code>dependencies {\n    \"implementation\"(libs.findLibrary(\"library.name\").get())\n}\n</code></pre></p> </li> </ol> <p>!!! TIP \"Tip\"      Keep your plugins focused and single-purpose. Create new plugins for distinct functionality rather than overloading existing ones.</p>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ol> <li>Module Organization:</li> <li>Use <code>jetpack.application</code> for the app module</li> <li>Use <code>jetpack.ui.library</code> for feature modules with UI</li> <li> <p>Use <code>jetpack.library</code> for core modules without UI</p> </li> <li> <p>Plugin Combinations: <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library) // Base UI setup\n    alias(libs.plugins.jetpack.dagger.hilt) // Add Hilt support\n    alias(libs.plugins.jetpack.firebase) // Add Firebase if needed\n}\n</code></pre></p> </li> <li> <p>Version Management:</p> </li> <li>Keep versions in the version catalog</li> <li>Reference them in plugins using <code>libs.findVersion()</code></li> </ol> <p>[!WARNING] Don't repeat plugin configurations in module-level build files. If you find yourself doing this, consider creating a new convention plugin instead.</p>"},{"location":"spotless/","title":"Spotless Linting Setup","text":"<p>This project uses Spotless for code formatting and license header management. Spotless is configured to work with Kotlin, Groovy, Gradle KTS files, and XML files.</p>"},{"location":"spotless/#features","title":"Features","text":"<p>The Spotless configuration includes: - Kotlin formatting using ktlint - Customizable formatting using <code>ktlint</code> and the <code>.editorconfig</code> file - Custom Compose UI rules for better Jetpack Compose code formatting - License header management for all supported file types - Gradle and XML file formatting</p>"},{"location":"spotless/#using-spotless","title":"Using Spotless","text":""},{"location":"spotless/#intellijandroid-studio-run-configurations","title":"IntelliJ/Android Studio Run Configurations","text":"<p>The project includes pre-configured run configurations in the <code>.run</code> directory:</p> <ol> <li>Spotless Check: Verifies if all files conform to the formatting rules</li> <li>Run using: <code>./gradlew spotlessCheck</code></li> <li> <p>Or use the \"Spotless Check\" run configuration in Android Studio</p> </li> <li> <p>Spotless Apply: Automatically formats all files according to the rules</p> </li> <li>Run using: <code>./gradlew spotlessApply</code></li> <li>Or use the \"Spotless Apply\" run configuration in Android Studio</li> </ol> <p>!!! TIP \"Tip\"      Always run Spotless Apply before committing your changes to ensure consistent code formatting.</p>"},{"location":"spotless/#cicd-integration","title":"CI/CD Integration","text":"<p>The project's GitHub Actions workflow automatically runs <code>spotlessCheck</code> on pull requests. Your PR will fail if there are any formatting issues.</p>"},{"location":"spotless/#customizing-copyright-headers","title":"Customizing Copyright Headers","text":"<p>The project includes default copyright headers in the <code>spotless</code> directory: - <code>copyright.kt</code> - For Kotlin files - <code>copyright.gradle</code> - For Gradle files - <code>copyright.kts</code> - For Kotlin Script files - <code>copyright.xml</code> - For XML files</p> <p>To use your own copyright headers:</p> <ol> <li>Navigate to the <code>spotless</code> directory</li> <li>Replace the content of the copyright files with your own headers</li> <li>Maintain the proper file format for each type</li> </ol> <p>Example copyright header for Kotlin files: <pre><code>/*\n * Copyright (c) 2024 Your Name/Organization\n * \n * Licensed under ...\n */\n</code></pre></p> <p>!!! NOTE \"Note\"      Make sure to update all copyright files to maintain consistency across different file types.</p>"},{"location":"spotless/#configuration-details","title":"Configuration Details","text":"<p>The Spotless configuration is defined in <code>gradle/init.gradle.kts</code> and includes:</p>"},{"location":"spotless/#kotlin-configuration","title":"Kotlin Configuration","text":"<pre><code>kotlin {\n    target(\"**/*.kt\")\n    targetExclude(\"**/build/**/*.kt\")\n    ktlint(ktlintVersion).editorConfigOverride(\n        mapOf(\n            \"android\" to \"true\",\n        ),\n    ).customRuleSets(\n        listOf(\n            \"io.nlopez.compose.rules:ktlint:0.4.16\",\n        ),\n    )\n    licenseHeaderFile(rootProject.file(\"spotless/copyright.kt\"))\n}\n</code></pre>"},{"location":"spotless/#other-file-types","title":"Other File Types","text":"<p>The configuration includes similar setups for: - Groovy (Gradle) files - Kotlin Script (<code>.kts</code>) files - XML files</p> <p>!!! warning \"Important\"      The build task will fail if any files don't match the formatting rules. Always run <code>spotlessApply</code> if <code>spotlessCheck</code> fails.</p>"},{"location":"spotless/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Pre-commit Hook: Consider setting up a pre-commit hook to run <code>spotlessApply</code>:    <pre><code>./gradlew spotlessApply\n</code></pre></p> </li> <li> <p>IDE Integration: Use the provided run configurations in Android Studio for easy access to Spotless commands.</p> </li> <li> <p>Regular Checks: Run Spotless Check periodically during development, not just before commits.</p> </li> <li> <p>Copyright Updates: Remember to update copyright years and organization information in the header files when necessary.</p> </li> </ol> <p>[!TIP] If you're using Android Studio, you can bind the Spotless Apply run configuration to a keyboard shortcut for quick formatting.</p>"},{"location":"tips/","title":"Tips and Tricks","text":"<p>Get the most out of this template with these useful tips and features.</p>"},{"location":"tips/#core-module-utilities","title":"Core Module Utilities","text":""},{"location":"tips/#core-android-utilities","title":"Core Android Utilities","text":"<p>The <code>core:android</code> module contains several helpful extensions and utilities:</p> <pre><code>// String Extensions\nemail.isEmailValid()                 // Email validation\npassword.isPasswordValid()           // Password validation\nname.isValidFullName()              // Name validation\n\n// Number Formatting\nnumber.format(nDecimal = 2)         // Format numbers with specific decimals\ntimestamp.asFormattedDateTime()      // Convert timestamp to readable date\n\n// Context Extensions\ncontext.showToast(message)          // Show toast message\ncontext.hasPermission(permission)    // Check single permission\ncontext.isAllPermissionsGranted()   // Check multiple permissions\ncontext.createNotificationChannel() // Create notification channel\n</code></pre>"},{"location":"tips/#core-ui-components","title":"Core UI Components","text":"<p>The <code>core:ui/components</code> directory contains pre-built Material3 composables:</p> <pre><code>// Pre-built components\nJetpackButton(onClick = {})\nJetpackOutlinedButton(onClick = {})\nJetpackTextButton(onClick = {})\nJetpackTextFiled(value = \"\", onValueChange = {})\nJetpackLoadingWheel(contentDesc = \"\")\nSwipeToDismiss(onDelete = {})\n</code></pre> <p>!!! TIP \"Tip\"      Always use these pre-built components instead of creating new ones. They provide consistent styling and can be modified centrally.</p>"},{"location":"tips/#theming-system","title":"Theming System","text":"<p>The <code>core:ui/theme</code> directory contains theming utilities:</p> <pre><code>// Custom theme\nJetpackTheme(\n    darkTheme = isDarkTheme,\n    disableDynamicTheming = true\n) {\n    // Your content\n}\n\n// Background with gradient\nAppGradientBackground(\n    gradientColors = gradientColors\n) {\n    // Your content\n}\n</code></pre>"},{"location":"tips/#network-state-monitoring","title":"Network State Monitoring","text":"<p>The <code>core:network</code> module provides network state monitoring:</p> <pre><code>class YourViewModel @Inject constructor(\n    private val networkUtils: NetworkUtils\n) : ViewModel() {\n    init {\n        networkUtils.networkState\n            .onEach { state -&gt;\n                when (state) {\n                    NetworkState.CONNECTED -&gt; // Handle connected state\n                    NetworkState.LOST -&gt; // Handle disconnected state\n                    NetworkState.UNAVAILABLE -&gt; // Handle unavailable state\n                }\n            }\n            .launchIn(viewModelScope)\n    }\n}\n</code></pre>"},{"location":"tips/#data-synchronization","title":"Data Synchronization","text":"<p>The <code>sync</code> module provides a robust way to synchronize local data with remote services:</p> <pre><code>// 1. Make your repository syncable\ninterface YourRepository : Syncable {\n    suspend fun sync(): Flow&lt;SyncProgress&gt;\n}\n\n// 2. Inject SyncManager in the repository implementation\nclass YourRepositoryImpl @Inject constructor(\n    private val syncManager: SyncManager\n) : YourRepository {\n    fun requestSync() {\n        syncManager.requestSync()\n    }\n}\n\n// 3. Inject repository into SyncWorker\n@HiltWorker\nclass SyncWorker @AssistedInject constructor(\n    private val yourRepository: YourRepository\n) : CoroutineWorker {\n    override suspend fun doWork(): Result {\n        yourRepository.sync()\n            .collect { progress -&gt;\n                setProgress(progress)\n            }\n        return Result.success()\n    }\n}\n</code></pre> <p>!!! NOTE \"Note\"      The sync module is already integrated with WorkManager for background synchronization. Just implement the Syncable interface in your repositories and inject them into the SyncWorker.</p>"},{"location":"tips/#secrets-management","title":"Secrets Management","text":"<p>The template includes the gradle-secrets-plugin for secure credentials management:</p> <pre><code># local.properties (git-ignored)\nAPI_KEY=your_actual_api_key\nAPI_SECRET=your_actual_secret\n\n# secrets.defaults.properties (version controlled)\nAPI_KEY=dummy_api_key\nAPI_SECRET=dummy_secret\n</code></pre> <p>Access secrets as <code>BuildConfig</code> fields:</p> <pre><code>    val apiKey = BuildConfig.apiKey\n</code></pre> <p>!!! TIP \"Tip\"      Use secrets.defaults.properties to provide dummy values for CI/CD environments while keeping sensitive data in local.properties.</p>"},{"location":"tips/#documentation-generation","title":"Documentation Generation","text":"<p>The template comes with Dokka setup for documentation generation:</p> <pre><code># Generate markdown documentation\n./gradlew dokkaGfmMultiModule --no-configuration-cache\n\n# The generated docs will be available in:\n# build/dokka/gfmMultiModule/\n</code></pre> <p>MkDocs is also configured to create beautiful Material theme documentation:</p> <pre><code># mkdocs.yml is already configured with:\n# - Material theme\n# - Search functionality\n# - Code highlighting\n# - Navigation structure\n</code></pre> <p>!!! NOTE \"Note\"      If you're using GitHub, the documentation is automatically generated and published through the docs workflow.</p>"},{"location":"tips/#error-handling-and-loading-states","title":"Error Handling and Loading States","text":""},{"location":"tips/#using-stateflow-updates","title":"Using StateFlow Updates","text":"<pre><code>// Regular state updates\n_uiState.updateState { \n    copy(value = newValue) \n}\n\n// Async operations that doesn't return anything\n_uiState.updateWith(viewModelScope) {\n    repository.someAsyncOperation()\n}\n\n// Async operations that returns results\n_uiState.updateStateWith(viewModelScope) {\n    repository.someAsyncOperation()\n}\n</code></pre>"},{"location":"tips/#automatic-error-handling","title":"Automatic Error Handling","text":"<pre><code>@Composable\nfun YourScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { data -&gt;\n        // Your UI content\n    }\n}\n</code></pre> <p>!!! NOTE \"Note\"      The error snackbar automatically includes a \"Report\" button that logs the error stack trace to Firebase Analytics.</p>"},{"location":"tips/#custom-snackbar-actions","title":"Custom Snackbar Actions","text":"<pre><code>// In ViewModel\nclass ScreenViewModel : ViewModel() {\n    fun undoDelete(itemId: String) {\n        _uiState.updateStateWith(viewModelScope) {\n            repository.undoDelete(itemId)\n        }\n    }\n}\n\n// In UI\n    StatefulComposable(\n        state = screenUiState,\n        onShowSnackbar = onShowSnackbar,\n    ) { screenData -&gt;\n        LaunchedEffect(screenData.deletedItemId, onShowSnackbar) {\n            val itemId = screenData.deletedItemId.getContentIfNotHandled()\n            if (itemId != null) {\n                val actionPerformed = onShowSnackbar(\n                    \"Item deleted\",\n                    SnackbarAction.UNDO,\n                    null\n                )\n                if (actionPerformed) viewModel.undoDelete(itemId)\n            }\n        }\n    }\n</code></pre>"},{"location":"tips/#composable-previews","title":"Composable Previews","text":"<p>Use the provided preview annotations for efficient UI development:</p> <pre><code>@Composable\n@PreviewThemes     // Preview in both light and dark themes\n@PreviewDevices    // Preview on different device sizes\nfun YourComposablePreview() {\n    JetpackTheme {\n        YourComposable()\n    }\n}\n</code></pre> <p>Preview devices include: - Phone (360x640dp) - Landscape (640x360dp) - Foldable (673x841dp) - Tablet (1280x800dp)</p>"},{"location":"tips/#coroutine-utilities","title":"Coroutine Utilities","text":"<pre><code>// Run with timeout\nval result = suspendCoroutineWithTimeout(5.seconds) {\n    // Your async operation\n}\n\n// Safe coroutine execution\nval result = suspendRunCatching {\n    // Your operation that might fail\n}\n</code></pre>"},{"location":"tips/#resource-management","title":"Resource Management","text":"<pre><code>// Network-bound resource handling\nfun getData(): Flow&lt;Resource&lt;Data&gt;&gt; = networkBoundResource(\n    query = { localDataSource.getData() },\n    fetch = { apiService.getData() },\n    saveFetchResult = { localDataSource.saveData(it) }\n)\n</code></pre>"},{"location":"tips/#ui-extensions","title":"UI Extensions","text":"<pre><code>// Lifecycle aware Flow collection\nlifeCycleOwner.collectWithLifecycle(flow) { data -&gt;\n    // Handle data\n}\n\n// LiveData observation\nlifeCycleOwner.observe(liveData) { data -&gt;\n    // Handle data\n}\n\n// One-time event observation\nlifeCycleOwner.observeEvent(eventLiveData) { event -&gt;\n    // Handle one-time event\n}\n</code></pre>"},{"location":"tips/#best-practices","title":"Best Practices","text":"<ol> <li>Use Pre-built Components</li> <li>Leverage the components in <code>core:ui/components</code></li> <li>Maintain consistent styling across the app</li> <li> <p>Centralize design system changes</p> </li> <li> <p>Error Handling</p> </li> <li>Use <code>suspendRunCatching</code> in repositories</li> <li>Let <code>StatefulComposable</code> handle UI states</li> <li> <p>Leverage the built-in error reporting</p> </li> <li> <p>State Management</p> </li> <li>Use state update helpers consistently</li> <li>Leverage <code>JetpackAppState</code> for app-wide state</li> <li> <p>Follow unidirectional data flow</p> </li> <li> <p>Network Handling</p> </li> <li>Monitor network state with <code>NetworkUtils</code></li> <li>Use network-bound resources for caching</li> <li> <p>Handle offline scenarios gracefully</p> </li> <li> <p>Resource Loading</p> </li> <li>Use <code>DynamicAsyncImage</code> for images</li> <li>Leverage <code>JetpackLoadingWheel</code></li> <li> <p>Follow Material3 loading patterns</p> </li> <li> <p>Documentation</p> </li> <li>Use Dokka for code documentation</li> <li>Keep documentation up to date</li> <li> <p>Leverage the automated docs workflow</p> </li> <li> <p>Secrets Management</p> </li> <li>Store sensitive data in local.properties</li> <li>Provide defaults in secrets.defaults.properties</li> <li>Use buildConfigField for config values</li> </ol> <p>[!TIP] Explore the <code>core</code> modules thoroughly - they contain many utilities that can save you time and ensure consistency across your app.</p>"}]}